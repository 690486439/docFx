var fs = require('fs');
var Mustache = require('mustache');
var jsyaml = require('js-yaml');
var path = require('path');
var mkdirp = require('mkdirp');

var extension = ".html";
var options = {encoding: 'utf8'};
var templateName = path.basename(process.cwd());
var content = fs.readFileSync( templateName +'.js', options);
var template = fs.readFileSync(templateName + '.tmpl', options);
eval(content);
var dir = "sample";
var output = "dist";
var root = "./";

var walk = function(dir, done) {
  var results = [];
  fs.readdir(dir, function(err, list) {
    if (err) return done(err);
    var pending = list.length;
    if (!pending) return done(null, results);
    list.forEach(function(file) {
      file = path.resolve(dir, file);
      fs.stat(file, function(err, stat) {
        if (stat && stat.isDirectory()) {
          walk(file, function(err, res) {
            results = results.concat(res);
            if (!--pending) done(null, results);
          });
        } else {
          results.push(file);
          if (!--pending) done(null, results);
        }
      });
    });
  });
};

walk(dir, function(err, files){
  parse(dir, output, root, err, files, function(file, index){
    // if (file.indexOf('Microsoft.DocAsCode.CustomAssemblyTextAttribute.yml') > -1) return true;
     if (path.extname(file) === '.yml') return true;
    return false;
  });
});

function getClosestFile(root, currentFile, targetFileName){
  var relative = path.relative(root, currentFile);
  var folders = relative.split(path.sep);
  var l = folders.length;
  if (l === 0 || folders[0] === '..') return null;
  while(l > 0){
    l--;
    relative = path.join(relative, '..');
    var file = path.join(root, relative, targetFileName);
    try{
      var stats = fs.lstatSync(file);
      if (stats.isFile()) return file;
    }catch(e){}
  }
  return null;
}

function parse(input, output, root, err, files, filter){
    if (err) return console.log(err);
    var extChanger = changeExt(extension);

    files.forEach(function(file, idx){
      if (!filter(file, idx)) return;
      input = path.resolve(input, root);
      output = path.resolve(output, root);
      //console.log(input);
      //return;
      var nav = extChanger(path.join(input, 'toc.yml'));
      var toc = extChanger(getClosestFile(input, file, 'toc.yml'));
      var currentFolder = path.dirname(file);
      var navRelPath = path.relative(currentFolder, nav)
      var tocRelPath = path.relative(currentFolder, toc);
      var navRel = path.dirname(navRelPath);
      var tocRel = path.dirname(tocRelPath);
      var rel = path.relative(currentFolder, root);
      var outputPath = path.join(output, path.relative(input, file));
      var outputFilePath = changeExt(extension)(outputPath);
      var outputModelFilePath = changeExt(".json")(outputPath);
      var attrs = {
        _lang: "csharp",
        _title: "Writing Documentations as writing code | Generated by docfx",
        _tocTitle: "Api Reference",
        _name: "Docfx",
        _tocPath: tocRelPath,
        _navPath: navRelPath,
        _ext: extension,
        _rel: rel,
        _navRel: navRel,
        _tocRel: tocRel,
        _description: "This description will be used in search results.",
      }
      fs.readFile(file, options, function(err, data){
        if (err) return console.log(err);
        var input = jsyaml.load(data);

        var model = transform(input, attrs);
        if (!model) return;
        var output = Mustache.render(template, model);
        if (/^\s*$/.test(output)){
          console.warn("WARNING: Template generated nothing for " + file);
        } else{
          var folder = path.dirname(outputFilePath);
          mkdirp.sync(folder);
          fs.writeFile(outputModelFilePath, JSON.stringify(model), options, function(err){
            if (err) return console.log(err);
          })
          fs.writeFile(outputFilePath, output, options, function(err){
            if (err) return console.log(err);
            console.log("Template generated to " + outputFilePath);
          })
        }
      })
  })
}

  function changeExt(e) {
    var ext = e;
    return function (path) {
      // if ext is empty, remove current extension
      if (!path || ext === undefined) return path;
      var pathWithoutExt = path.substring(0, path.lastIndexOf('.'));
      if (ext && ext[0] !== '.') return pathWithoutExt + '.' + ext;

      return pathWithoutExt + ext;
    }
  }

